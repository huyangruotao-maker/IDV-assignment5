<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IDV Assignment 4 – Robustness Benchmark Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.18);
      --accent-purple: #a855f7;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --grid: #1f2937;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 32px 16px 40px;
      display: flex;
      justify-content: center;
    }

    .page {
      width: 100%;
      max-width: 1160px;
    }

    header {
      margin-bottom: 24px;
    }

    header h1 {
      font-size: 1.9rem;
      margin: 0 0 8px;
      letter-spacing: 0.04em;
    }

    header p {
      margin: 0;
      color: var(--text-muted);
      font-size: 0.95rem;
      max-width: 720px;
    }

    .badge-row {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .header-badge {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.8);
      color: var(--text-muted);
    }

    .layout-top {
      display: grid;
      grid-template-columns: minmax(0, 2.5fr) minmax(260px, 1fr);
      gap: 18px;
      margin-bottom: 18px;
    }

    .layout-bottom {
      margin-top: 4px;
    }

    @media (max-width: 880px) {
      .layout-top {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: radial-gradient(circle at top left, #1f2937 0, #020617 70%);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.18);
      box-shadow:
        0 18px 45px rgba(15,23,42,0.9),
        0 0 0 1px rgba(148,163,184,0.18);
      padding: 18px 18px 16px;
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at 0% 0%, rgba(56,189,248,0.14) 0, transparent 48%),
        radial-gradient(circle at 100% 100%, rgba(168,85,247,0.12) 0, transparent 55%);
      opacity: 0.85;
      pointer-events: none;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 8px;
    }

    .card-title {
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .card-subtitle {
      font-size: 0.8rem;
      color: var(--accent);
    }

    .card-subtitle span {
      color: var(--text-muted);
    }

    #chart-container,
    #chart2-container {
      margin-top: 10px;
    }

    svg {
      width: 100%;
      background: linear-gradient(180deg, rgba(15,23,42,0.95), #020617 70%);
      border-radius: 12px;
    }

    #chartSvg {
      height: 420px;
    }

    #chart2Svg {
      height: 380px;
    }

    .axis path, .axis line {
      stroke: #4b5563;
    }

    .axis text {
      fill: var(--text-muted);
      font-size: 11px;
    }

    .y-grid line {
      stroke: var(--grid);
      stroke-dasharray: 2,4;
    }

    .bar {
      rx: 4;
      ry: 4;
      cursor: pointer;
    }

    .bar:hover {
      stroke: #f9fafb;
      stroke-width: 1px;
      filter: drop-shadow(0 0 8px rgba(56,189,248,0.45));
    }

    .heat-cell {
      rx: 2;
      ry: 2;
      cursor: pointer;
    }

    .heat-cell.dimmed {
      opacity: 0.35;
    }

    .heat-cell:hover {
      stroke: #f9fafb;
      stroke-width: 0.8px;
      filter: drop-shadow(0 0 8px rgba(56,189,248,0.5));
    }

    .tooltip {
      position: absolute;
      pointer-events: none;
      background: #020617;
      border-radius: 8px;
      padding: 7px 10px;
      font-size: 12px;
      color: var(--text-main);
      border: 1px solid rgba(148,163,184,0.6);
      box-shadow: 0 12px 30px rgba(15,23,42,0.9);
      visibility: hidden;
      white-space: nowrap;
      z-index: 20;
    }

    .tooltip strong {
      color: var(--accent);
    }

    /* Controls */
    .controls {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .control-label {
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }

    select {
      background: rgba(15,23,42,0.92);
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      padding: 6px 10px;
      color: var(--text-main);
      font-size: 0.82rem;
      outline: none;
      appearance: none;
      position: relative;
    }

    select:focus {
      box-shadow: 0 0 0 1px var(--accent-soft);
      border-color: var(--accent);
    }

    /* Side panel */
    .side-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.5);
      font-size: 0.75rem;
      color: var(--text-muted);
      margin: 0 4px 4px 0;
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
    }

    .stat-grid {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .stat {
      background: rgba(15,23,42,0.9);
      border-radius: 12px;
      padding: 8px 10px;
      border: 1px solid rgba(31,41,55,0.9);
    }

    .stat-label {
      font-size: 0.72rem;
      color: var(--text-muted);
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 1rem;
      font-weight: 500;
    }

    .legend {
      margin-top: 10px;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .hint {
      margin-top: 6px;
      font-size: 0.7rem;
      color: var(--text-muted);
      opacity: 0.9;
    }

    /* Bottom card specific */
    .controls-wide {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1.4fr);
      gap: 10px;
      margin-top: 8px;
    }

    @media (max-width: 720px) {
      .controls,
      .controls-wide {
        grid-template-columns: minmax(0, 1fr);
      }
    }
  </style>
</head>
<body>
<div class="page">
  <header>
    <h1>Robustness Benchmark Dashboard</h1>
    <p>
      Interactive D3.js visualisation for IDV Assignment&nbsp;4.
      The first chart explores <strong>methods × metrics × datasets</strong> (data_1.json),
      and the second chart uses a <strong>heatmap for methods × attacks</strong> (data_2.json).
    </p>
    <div class="badge-row">
      <span class="header-badge">Data-Driven · D3.js · GitHub Pages</span>
      <span class="header-badge">Std Acc · CRR · CRA · Attack Heatmap</span>
    </div>
  </header>

  <!-- Top layout: main metrics chart + side info -->
  <div class="layout-top">
    <!-- Main chart card (data_1.json) -->
    <section class="card">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <div class="card-title">Metrics View</div>
            <div class="card-subtitle" id="chartSubtitle">
              Loading metric & dataset…
            </div>
          </div>
        </div>

        <div class="controls">
          <div class="control-group">
            <span class="control-label">Metric</span>
            <select id="metricSelect"></select>
          </div>
          <div class="control-group">
            <span class="control-label">Dataset</span>
            <select id="datasetSelect"></select>
          </div>
        </div>

        <div id="chart-container">
          <svg id="chartSvg" viewBox="0 0 900 420" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
      </div>
    </section>

    <!-- Side info card -->
    <aside class="card">
      <div class="card-inner">
        <div class="side-title">Current View</div>

        <div id="currentPills"></div>

        <div class="stat-grid" id="statGrid"></div>

        <div class="legend" id="legendBox"></div>

        <div class="hint">
          • Top chart: grouped bar chart for <code>data_1.json</code>.<br/>
          • Hover bars to see exact values (interaction).<br/>
          • Bars animate when you change metric / dataset (transition).
        </div>
      </div>
    </aside>
  </div>

  <!-- Bottom layout: attacks heatmap (data_2.json) -->
  <div class="layout-bottom">
    <section class="card">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <div class="card-title">Attacks Heatmap</div>
            <div class="card-subtitle" id="chart2Subtitle">
              Accuracy of methods under different attacks (data_2.json)
            </div>
          </div>
        </div>

        <div class="controls-wide">
          <div class="control-group">
            <span class="control-label">Attack order</span>
            <select id="attackSortSelect">
              <option value="original">Original (table order)</option>
              <option value="alpha">Attack name A → Z</option>
              <option value="meanDesc">Mean accuracy high → low</option>
              <option value="meanAsc">Mean accuracy low → high</option>
            </select>
          </div>
          <div class="control-group">
            <span class="control-label">Highlight method</span>
            <select id="highlightMethodSelect">
              <option value="all">All methods</option>
            </select>
          </div>
        </div>

        <div id="chart2-container">
          <svg id="chart2Svg" viewBox="0 0 900 380" preserveAspectRatio="xMidYMid meet"></svg>
        </div>

        <div class="hint">
          • Bottom chart: heatmap for <code>data_2.json</code> (attacks × methods).<br/>
          • Use the controls to reorder attacks and highlight a specific method.<br/>
          • Hover cells to inspect exact accuracy values (interaction + animated transitions).
        </div>
      </div>
    </section>
  </div>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
  const tooltip = d3.select("#tooltip");

  /***********************
   * Helper formatters
   ************************/
  function formatMetric(metricKey) {
    if (metricKey === "Std Acc") return "Standard Accuracy";
    if (metricKey === "CRR") return "Certified Robustness Rate";
    if (metricKey === "CRA") return "Certified Robust Accuracy";
    return metricKey;
  }

  function formatDataset(dsKey) {
    if (dsKey === "CIFAR100") return "CIFAR-100";
    if (dsKey === "CIFAR10") return "CIFAR-10";
    return dsKey;
  }

  /***************************************
   * Chart 1 – data_1.json (metrics view)
   ***************************************/
  (function initChart1() {
    const svg = d3.select("#chartSvg");
    const margin = { top: 40, right: 20, bottom: 90, left: 70 };
    const innerWidth = 900 - margin.left - margin.right;
    const innerHeight = 420 - margin.top - margin.bottom;

    const chartGroup = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const xScale = d3.scaleBand().padding(0.25);
    const yScale = d3.scaleLinear();
    const colorScale = d3.scaleOrdinal(d3.schemeTableau10);

    const xAxisGroup = chartGroup.append("g")
      .attr("class", "axis x-axis")
      .attr("transform", `translate(0, ${innerHeight})`);
    const yAxisGroup = chartGroup.append("g")
      .attr("class", "axis y-axis");

    const yGrid = chartGroup.append("g").attr("class", "y-grid");

    const metricSelect = d3.select("#metricSelect");
    const datasetSelect = d3.select("#datasetSelect");

    function updateSidePanel(data, metricKey, datasetKey, approaches, colorScale) {
      const pillsBox = d3.select("#currentPills");
      const statGrid = d3.select("#statGrid");
      const legendBox = d3.select("#legendBox");
      const subtitle = d3.select("#chartSubtitle");

      pillsBox.html("");
      statGrid.html("");
      legendBox.html("");

      pillsBox
        .append("div")
        .attr("class", "pill")
        .html(`<span class="pill-dot"></span><span>Metric: ${formatMetric(metricKey)}</span>`);

      pillsBox
        .append("div")
        .attr("class", "pill")
        .html(`<span class="pill-dot" style="background:${"#a855f7"};"></span>
               <span>Dataset: ${formatDataset(datasetKey)}</span>`);

      const values = data.map(d => d.value);
      const maxVal = d3.max(values);
      const minVal = d3.min(values);
      const meanVal = d3.mean(values);

      statGrid.append("div").attr("class", "stat")
        .html(`
          <div class="stat-label">Highest</div>
          <div class="stat-value">${maxVal.toFixed(2)}</div>
        `);

      statGrid.append("div").attr("class", "stat")
        .html(`
          <div class="stat-label">Lowest</div>
          <div class="stat-value">${minVal.toFixed(2)}</div>
        `);

      statGrid.append("div").attr("class", "stat")
        .html(`
          <div class="stat-label">Average</div>
          <div class="stat-value">${meanVal.toFixed(2)}</div>
        `);

      statGrid.append("div").attr("class", "stat")
        .html(`
          <div class="stat-label">Approaches</div>
          <div class="stat-value">${data.length}</div>
        `);

      legendBox.append("div")
        .style("margin-bottom", "4px")
        .text("Color encodes robustness approach:");

      const legendItems = legendBox.selectAll(".legend-item")
        .data(approaches)
        .enter()
        .append("div")
        .attr("class", "legend-item");

      legendItems.append("div")
        .attr("class", "legend-swatch")
        .style("background", d => colorScale(d));

      legendItems.append("div")
        .text(d => d);

      subtitle.text(`${formatMetric(metricKey)} on ${formatDataset(datasetKey)}`);
    }

    d3.json("data_1.json").then(raw => {
      const approaches = Object.keys(raw);
      const metrics   = Object.keys(raw[approaches[0]]);
      const datasets  = Object.keys(raw[approaches[0]][metrics[0]]);

      metricSelect.selectAll("option")
        .data(metrics)
        .enter()
        .append("option")
        .attr("value", d => d)
        .text(d => formatMetric(d));

      datasetSelect.selectAll("option")
        .data(datasets)
        .enter()
        .append("option")
        .attr("value", d => d)
        .text(d => formatDataset(d));

      metricSelect.property("value", metrics[0]);
      datasetSelect.property("value", datasets[0]);

      function getCurrentData(metricKey, datasetKey) {
        return approaches.map(a => ({
          approach: a,
          metric: metricKey,
          dataset: datasetKey,
          value: raw[a][metricKey][datasetKey]
        }));
      }

      function updateChart(metricKey, datasetKey, animate = true) {
        const data = getCurrentData(metricKey, datasetKey);

        xScale
          .domain(data.map(d => d.approach))
          .range([0, innerWidth]);

        yScale
          .domain([0, d3.max(data, d => d.value) * 1.05])
          .range([innerHeight, 0])
          .nice();

        colorScale.domain(approaches);

        const xAxis = d3.axisBottom(xScale);
        const yAxis = d3.axisLeft(yScale).ticks(6);

        xAxisGroup.transition().duration(animate ? 500 : 0)
          .call(xAxis)
          .selectAll("text")
          .attr("transform", "rotate(18)")
          .style("text-anchor", "start")
          .style("font-size", "11px");

        yAxisGroup.transition().duration(animate ? 500 : 0)
          .call(yAxis);

        yGrid
          .call(d3.axisLeft(yScale)
            .tickSize(-innerWidth)
            .tickFormat(""))
          .selectAll("line")
          .attr("stroke-dasharray", "2,4");

        const bars = chartGroup.selectAll(".bar")
          .data(data, d => d.approach);

        bars.enter()
          .append("rect")
          .attr("class", "bar")
          .attr("x", d => xScale(d.approach))
          .attr("width", xScale.bandwidth())
          .attr("y", innerHeight)
          .attr("height", 0)
          .attr("fill", d => colorScale(d.approach))
          .on("mouseover", function(event, d) {
            tooltip
              .style("visibility", "visible")
              .html(`
                <strong>${d.approach}</strong><br/>
                ${formatMetric(d.metric)}<br/>
                ${formatDataset(d.dataset)}: ${d.value.toFixed(2)}
              `);
            d3.select(this).style("opacity", 0.8);
          })
          .on("mousemove", function(event) {
            tooltip
              .style("top", (event.pageY - 32) + "px")
              .style("left", (event.pageX + 12) + "px");
          })
          .on("mouseout", function() {
            tooltip.style("visibility", "hidden");
            d3.select(this).style("opacity", 1);
          })
          .merge(bars)
          .transition()
          .duration(animate ? 700 : 0)
          .attr("x", d => xScale(d.approach))
          .attr("width", xScale.bandwidth())
          .attr("y", d => yScale(d.value))
          .attr("height", d => innerHeight - yScale(d.value))
          .attr("fill", d => colorScale(d.approach));

        bars.exit()
          .transition()
          .duration(400)
          .attr("y", innerHeight)
          .attr("height", 0)
          .remove();

        updateSidePanel(data, metricKey, datasetKey, approaches, colorScale);
      }

      // 初次渲染
      updateChart(metrics[0], datasets[0], true);

      metricSelect.on("change", () => {
        const metricKey = metricSelect.property("value");
        const datasetKey = datasetSelect.property("value");
        updateChart(metricKey, datasetKey, true);
      });

      datasetSelect.on("change", () => {
        const metricKey = metricSelect.property("value");
        const datasetKey = datasetSelect.property("value");
        updateChart(metricKey, datasetKey, true);
      });
    }).catch(err => {
      console.error("Failed to load data_1.json:", err);
      d3.select("#chart-container")
        .append("p")
        .style("color", "tomato")
        .text("Failed to load data_1.json. Please check the file path and JSON format.");
    });
  })();

  /******************************************
   * Chart 2 – data_2.json (attacks heatmap)
   ******************************************/
  (function initChart2() {
    const svg2 = d3.select("#chart2Svg");
    const margin2 = { top: 40, right: 20, bottom: 110, left: 110 };
    const innerWidth2 = 900 - margin2.left - margin2.right;
    const innerHeight2 = 380 - margin2.top - margin2.bottom;

    const chartGroup2 = svg2.append("g")
      .attr("transform", `translate(${margin2.left},${margin2.top})`);

    const x2 = d3.scaleBand().padding(0.1);
    const y2 = d3.scaleBand().padding(0.1);
    const yAxisGroup2 = chartGroup2.append("g")
      .attr("class", "axis y-axis");
    const xAxisGroup2 = chartGroup2.append("g")
      .attr("class", "axis x-axis")
      .attr("transform", `translate(0, ${innerHeight2})`);
    const yGrid2 = chartGroup2.append("g").attr("class", "y-grid");

    const attackSortSelect = d3.select("#attackSortSelect");
    const highlightMethodSelect = d3.select("#highlightMethodSelect");
    const subtitle2 = d3.select("#chart2Subtitle");

    d3.json("data_2.json").then(raw2 => {
      // raw2: { Attack: {ERM:..., DA:..., ...}, ... }
      const attacksOriginal = Object.keys(raw2);
      const methods = Object.keys(raw2[attacksOriginal[0]]);

      // 填充 highlight method 下拉框
      highlightMethodSelect.selectAll("option.method-opt")
        .data(methods)
        .enter()
        .append("option")
        .attr("class", "method-opt")
        .attr("value", d => d)
        .text(d => d);

      // 构建完整 cell 数组
      const allCells = [];
      attacksOriginal.forEach(atk => {
        methods.forEach(m => {
          allCells.push({
            attack: atk,
            method: m,
            value: raw2[atk][m]
          });
        });
      });

      const globalMin = d3.min(allCells, d => d.value);
      const globalMax = d3.max(allCells, d => d.value);

      function colorForValue(v) {
        const t = (v - globalMin) / (globalMax - globalMin || 1);
        const light = 22 + t * 38; // 22% ~ 60%
        const hue = 200 - t * 40;  // 从蓝青到蓝紫
        return `hsl(${hue}, 88%, ${light}%)`;
      }

      function computeAttackOrder(mode) {
        if (mode === "original") {
          return attacksOriginal.slice();
        }
        if (mode === "alpha") {
          return attacksOriginal.slice().sort((a, b) => d3.ascending(a.toLowerCase(), b.toLowerCase()));
        }
        // 计算每个 attack 的平均值
        const attackMeans = attacksOriginal.map(atk => {
          const vals = methods.map(m => raw2[atk][m]);
          return { attack: atk, mean: d3.mean(vals) };
        });
        if (mode === "meanDesc") {
          return attackMeans.sort((a, b) => d3.descending(a.mean, b.mean)).map(d => d.attack);
        }
        if (mode === "meanAsc") {
          return attackMeans.sort((a, b) => d3.ascending(a.mean, b.mean)).map(d => d.attack);
        }
        return attacksOriginal.slice();
      }

      function updateHeatmap(animate = true) {
        const sortMode = attackSortSelect.property("value");
        const highlightMethod = highlightMethodSelect.property("value");

        const attacks = computeAttackOrder(sortMode);

        x2.domain(methods).range([0, innerWidth2]);
        y2.domain(attacks).range([0, innerHeight2]);

        const xAxis2 = d3.axisBottom(x2);
        const yAxis2 = d3.axisLeft(y2);

        xAxisGroup2.transition().duration(animate ? 500 : 0)
          .call(xAxis2)
          .selectAll("text")
          .attr("transform", "rotate(0)")
          .style("text-anchor", "middle")
          .style("font-size", "11px");

        yAxisGroup2.transition().duration(animate ? 500 : 0)
          .call(yAxis2)
          .selectAll("text")
          .style("font-size", "11px");

        // grid lines（横向）
        yGrid2
          .call(d3.axisLeft(y2)
            .tickSize(-innerWidth2)
            .tickFormat(""))
          .selectAll("line")
          .attr("stroke-dasharray", "2,4");

        // 过滤 / 排序后的cells
        const visibleCells = allCells.filter(d => attacks.indexOf(d.attack) !== -1);

        const cells = chartGroup2.selectAll(".heat-cell")
          .data(visibleCells, d => d.attack + "-" + d.method);

        cells.enter()
          .append("rect")
          .attr("class", "heat-cell")
          .attr("x", d => x2(d.method))
          .attr("y", d => y2(d.attack))
          .attr("width", x2.bandwidth())
          .attr("height", y2.bandwidth())
          .attr("fill", d => colorForValue(d.value))
          .on("mouseover", function(event, d) {
            tooltip
              .style("visibility", "visible")
              .html(`
                <strong>${d.attack}</strong><br/>
                Method: ${d.method}<br/>
                Accuracy: ${d.value.toFixed(2)}
              `);
            d3.select(this).style("opacity", 0.9);
          })
          .on("mousemove", function(event) {
            tooltip
              .style("top", (event.pageY - 32) + "px")
              .style("left", (event.pageX + 12) + "px");
          })
          .on("mouseout", function() {
            tooltip.style("visibility", "hidden");
            d3.select(this).style("opacity", 1);
          })
          .merge(cells)
          .transition()
          .duration(animate ? 700 : 0)
          .attr("x", d => x2(d.method))
          .attr("y", d => y2(d.attack))
          .attr("width", x2.bandwidth())
          .attr("height", y2.bandwidth())
          .attr("fill", d => colorForValue(d.value));

        cells.exit()
          .transition()
          .duration(400)
          .attr("opacity", 0)
          .remove();

        // 高亮某个方法
        chartGroup2.selectAll(".heat-cell")
          .classed("dimmed", d =>
            highlightMethod !== "all" && d.method !== highlightMethod
          );

        // 更新副标题
        let sortLabel = "";
        if (sortMode === "original") sortLabel = "original table order";
        else if (sortMode === "alpha") sortLabel = "attack name (A → Z)";
        else if (sortMode === "meanDesc") sortLabel = "mean accuracy (high → low)";
        else if (sortMode === "meanAsc") sortLabel = "mean accuracy (low → high)";

        subtitle2.text(
          `Accuracy heatmap · Attacks on rows, methods on columns · Attack order: ${sortLabel}`
        );
      }

      // 初始化一次
      updateHeatmap(true);

      attackSortSelect.on("change", () => updateHeatmap(true));
      highlightMethodSelect.on("change", () => updateHeatmap(false));
    }).catch(err => {
      console.error("Failed to load data_2.json:", err);
      d3.select("#chart2-container")
        .append("p")
        .style("color", "tomato")
        .text("Failed to load data_2.json. Please check the file path and JSON format.");
    });
  })();
</script>
</body>
</html>
